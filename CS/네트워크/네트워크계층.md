## 네트워크 계층

네트워크에는 다양한 기기간 통신을 위해 약속된 구조가 있다.

- OSI 7계층
  네트워크를 개념적으로 나눈 계층
- TCP/IP 4계층
  실제 인터넷 통신에 사용되는 계층

<br />

### OSI 7계층

국제 표준화 기구에서 네트워크 통신이 이뤄지는 과정을 7단계로 나눈 네트워크 표준 모델

- 데이터를 송신할 때는 높은 계층에서 낮은 계층으로 전달한다.
- 데이터를 수신할 때는 낮은 계층에서 높은 계층으로 전달한다.

<br />

각 계층은 독립적이며 각 계층에서 `헤더(header)`와 `트레일러(trailer)`를 붙여 다음 계층으로 전달한다.

이를 `데이터 캡슐화`라고 하며, 수신부의 같은 계층에서 데이터 호환성을 높이고 오류의 영향을 최소화하기 위한 것이다.

수신부는 데이터의 헤더와 트레일러를 분석해 제거하며 `역캡슐화`를 진행한다.

이 과정에서 각 계층은 필요한 제어 정보를 얻는다.

> 프로토콜(통신 규약)
> 데이터를 송수신하기 위해 정한 규칙

- 7계층(`응용 계층`, Application Layer)
  최종 목적지로, 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다. (explore, chrome 등)
  `HTTP`, `FTP`, `SMTP`, `POP3`, `IMAP`, `Telnet` 등의 프로토콜을 응용 프로그램의 UI를 통해 제공한다.
- 6계층(`표현 계층`, Presentation Layer)
  데이터를 표준화된 형식으로 변경한다. (데이터 변환, 압축, 암호화 등)
  파일 인코딩, 명령어를 포장, 압축, 암호화
  JPEG, MPEG, GIF, ASCII 등
- 5계층(`세션 계층`, Session Layer)
  세션의 유지 및 해제 등 응용 프로그램 간 통신 제어와 동기화를 한다.
  주 지점간의 프로세스 및 통신하는 호스트 간의 연결을 유지한다.
  TCP/IP 세션 체결, 포트 번호를 기반으로 통신 세션 구성
  API, Socket
- 4계층(`전송 계층` , Transport Layer)
  신뢰성 있는 데이터를 전달하기 위한 계층
  TCP, UDP 같은 전송 방식과 포트 번호 등을 결정한다.
  port 번호, 전송방식(TCP/UDP) 결정 → TCP 헤더 붙음
  신호를 분산하고 다시 합치는 과정을 통해 에러와 경로를 제어
- 3계층(`네트워크 계층` , Network Layer)
  데이터를 송신부에서 수신부까지 보내기 위한 최적 경로를 선택하는 라우팅을 수행한다.
  이때 선택한 최적 경로를 `라우트`라고 한다. 네트워크 계층의 장비로는 `라우터`가 있다.
  라우터를 통해 경로를 선택하고 주소를 정하고(IP) 경로(Route)에 따라 패킷을 전달 → IP 헤더 붙음
  이 계층에서 전송되는 단위: `패킷`(Packet)
- 2계층(`데이터 링크계층` , DataLink Layer)
  물리계층을 통해 송수신되는 데이터 흐름을 관리하며 데이터의 오류 검출 및 복구 등을 수행한다.
  `브리지(brige)`, `스위치(switch)`, `이더넷(ethernet)`이 데이터 링크 계층의 장비에 해당한다.
  프레임에 물리적 주소(`MAC address`)를 부여하고 에러검출, 재전송, 흐름제어를 수행
  이 계층에서 전송되는 단위: `프레임(Frame)`
  브릿지나 스위치를 통해 `맥주소`를 가지고 물리계층에서 받은 정보를 전달한다.(수신)
- 1계층(`물리 계층`, Physical Layer)
  데이터를 비트단위의 0과 1로 변환한 후 장비를 사용해 전송하거나 전기 신호를 데이터로 복원한다. 리피터(repeater), 허브(hub) 등이 물리 계층에 해당하는 장비다.
  주로 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송하는 물리적인 장비

<br />

### Hub(허브)

- OSI 7계층 중 1계층인 물리계층에서 동작하는 장비
- 다수의 pc 장치들을 묶어서 LAN을 구성할 때 각각의 PC에 연결된 노드들을 한 곳으로 모으는 역할을 해주는 장치
- 중심축에 놓여 여러 컴퓨터들을 연결해 네트워크를 만들어주는 역할
- UTP 랜 케이블을 이용하여 가까운 거리에 있는 컴퓨터들을 연결시켜 주는 네트워크 장비

<br />

허브의 작동 원리

- 허브는 단순히 중계기 역할
- 컴퓨터 b가 컴퓨터 c로 신호를 보내면, 그 신호는 c한테만 가는게 아니라 연결된 모든 컴퓨터로 전송
- 즉, 모든 신호를 `브로드캐스트(Broadcast)`함.
  (원하지 않는 데이터를받게 된 나머지 포트에 연결된 컴퓨터들은 데이터를 폐기함 → 과도한 트래픽, 충돌 발생)

<br />

### Repeater(리피터)

- OSI 7계층 중에서 1계층인 물리계층에서 동작하는 장비
- 근거리 통신망을 구성하는 세그먼트들을 확장하거나 서로 연결하는데 주로 사용
- 신호를 수신하여 신호를 증폭한 후 다음 구간으로 재전송하는 장치를 말한다.
- 전자기장 확산이나 케이블 손실로 인한 신호 감쇠를 보상해주기 때문에, 여러 대의 Repeater를 써서 신호를 먼 거리까지 데이터를 전달하는 것이 가능
- 통신하는 상대방이 멀리 있을 때 리피터를 사이에 넣어 사용해 즉, 멀리 있는 상대방과도 통신할 수 있도록 파형을 정상으로 만드는 기능을 한다.
- 요샌 다른 네트워크 장비가 리피터 기능을 지원하기에 따로 리피터를 쓸 필요는 없다.

<br />

### Switch(스위치)

- OSI 7계층 중에서 2계층인 데이터링크 계층에서 동작하는 장비
- 같은 네트워크 안에서 데이터를 전송해주는 네트워크 장비로, 컴퓨터를 스위치에 연결하는 것은 네트워크에 연결되는 것과 같다고 볼 수 있다.
- PC에 LAN이 제공하는 대역폭을 연결된 PC의 대수와 관계없이 고스란히 전달한다.
- 스위치는 정보를 동시에 주고 받을 수 있어 허브보다 빨리 정보를 보내고 받는다.
- MAC 주소와 포트번호가 기록된 MAC 주소 테이블을 가지고 있다.
- MAC 주소를 가진 장비가 연결된 포트로만 프레임을 전송한다.

<br />

한 포트에서 전송된 프레임이 MAC 주소 테이블에 있는 특정 포트로만 전송되기 때문에 다른 포트가 전송하는 프레임과 충돌이 일어나지 않는다.

그러므로 네트워크 성능이 향상되고, 보안성도 좋아진다.

> LAN
> 근거리 통신망, 로컬 영역 네트워크 (local area network, LAN), 구내 정보 통신망은 네트워크 매체를 이용하여 집, 사무실, 학교 등의 건물과 같은 가까운 지역을 한데 묶는 컴퓨터 네트워크이다.

WAN
광역 통신망, 더 넓은 지역 범위를 아우를 뿐 아니라 일반적으로 전용선 또한 동반한다.

>

<br />

## TCP/IP 4계층

인터넷에서 데이터를 주고받기 위한 네트워크 프로토콜

- TCP
  데이터를 나눈 단위인 `패킷`의 전달여부와 전송 순서를 보장하는 통신 방식
- IP
  패킷을 빠르게 보내기 위한 통신 방식

TCP/IP 기반 프로토콜에는 대표적으로 `HTTP`가 있다.

TCP/IP에 맞춰 네트워크 통신 표준인 OSI 7계층을 단순화한 것이 TCP/IP 4계층이다.

<br />

- 4계층(응용계층)
  사용자와 소프트웨어를 연결해주는 계층으로 ,HTTP, HTTPS, DNS 등의 프로토콜이 작동한다.
  OSI 7계층의 세션 계층(5), 표현 계층(6), 응용 계층(7)에 해당한다.
  프로그램(브라우저)가 직접 interact 하는 레이어로, 데이터를 처음으로 받는 곳이다.
  다른 계층의 서비스에 접근할 수 있게 하는 애플리케이션을 제공한다.
  애플리케이션들이 데이터를 교환하기 위해 사용하는 프로토콜을 정의한다.
  응용 계층의 데이터 단위: 메시지
- 3계층(전송 계층)
  OSI 7계층의 전송 계층(4)에 해당한다.
  IP와 port를 이용하여 프로세스와 통신한다.
  데이터의 신뢰성을 보장하며, 포트 번호로 데이터를 적절한 응용 프로그램에 전달하는 역할을 한다. TCP, UDP 등의 프로토콜이 전송 계층에 속한다.
  전송 계층의 데이터 단위: 세그먼트
- 2계층(인터넷 계층)
  OSI 7계층의 네트워크 계층(3)에 해당한다.
  어드레싱(addressing), 패키징(packaging), 라우팅(routing) 기능을 제공
  데이터를 최종 목적지까지 도달할 수 있게 하는 계층으로, IP가 대표적인 프로토콜이다. 인터넷 계층에서는 전송 계층으로부터 받은 데이터에 헤더를 붙여 캡슐화하는데, 이를 패킷 또는 데이터그램이라고 한다.
- 1계층(네트워크 인터페이스 계층)
  OSI 7계층의 물리계층(1)과 데이터 링크 계층(2)에 해당한다.
  TCP/IP 패킷을 네트워크 매체로 전달하는 것과 네트워크 매체에서 TCP/IP 패킷을 받아들이는 과정을 담당한다.
  에러 검출 기능, 패킷의 프레임화
  데이터를 전기 신호로 변환하고 MAC 주소를 사용해 기기에 데이터를 전달한다.
  이더넷, wi-fi 등이 해당 계층에 속하는 대표적인 프로토콜이다.
  데이터 단위: 프레임

> 패킷
> 네트워크에서 주고받는 데이터를 작게 분할한 단위를 나타낸다.
> 패킷에는 데이터의 송신 주소, 수신 주소 등의 정보가 포함되어 데이터를 목적지에 제대로 전달할 수 있게 한다.

<br />

## IP 주소(IP address)

IP에서 컴퓨터 또는 네트워크 장치를 식별하기 위한 값
네트워크부와 호스트부로 나뉜다.

- 네트워크부: 해당 주소가 어떠한 네트워크에 속해 있는지 구분하는 값
- 호스트부: 해당 네트워크에서 어떠한 기기인지를 나타내는 값

<br />

### 서브넷 마스크

IP 주소를 네트워크부, 호스트부로 나누는데 사용되는 숫자 조합이다.

연속적인 1과 0으로 구성되어 있어서 IP 주소와 and 연산을 하면 IP 주소에서 네트워크부와 호스트부를 알아낼 수 있다.

`서브넷 마스크`는 IP 주소와 같은 길이의 비트로 구성되며, 이진수로 표현했을 때 네트워크부는 1로, 호스트부는 0으로 설정된다.

<br />

### 서브넷 마스크를 사용하는 이유

하나의 네트워크 안에는 클래스에 따라 수만개 이상의 호스트를 가지게 되는데, 단일 네트워크의 크기가 너무 큰 경우 특정 기기와의 통신을 시도할 때 브로드캐스트의 영향이 너무 크기 때문에 서브넷 마스크를 사용해 네트워크를 쪼개어 캐스트 영역을 보다 작은 네트워크(서브넷)으로 나눌 수 있다. 이를 통해 작은 네트워크를 조직화하고 관리할 수 있다.

<br/>

## TCP와 UDP

`전송계층`에서 사용하는 대표적인 프로토콜

<br />

### TCP

연결형 서비스를 지원하고 데이터의 신뢰성을 보장한다.

- 송신부와 수신부의 연결을 확인하는 연결형 서비스
- 패킷 교환 방식은 패킷이 전달되는 회선이 정해져 있는 가상 회선 방식
- 패킷의 전송 순서가 보장된다.
- 패킷의 수신 여부를 확인
- 송신부와 수신부는 1:1 통신을 한다.
- 데이터 손실이 없음을 보장하므로 신뢰성이 높다.
- 데이터의 송수신 속도가 느리다.

> 패킷 교환 방식

- 가상 회선 방식
  데이터를 주고받기 전에 패킷을 전송할 경로인 가상 회선을 설정해서 모든 패킷을 같은 경로로 전송한다. 연결 지향형

- 데이터그램 방식
  패킷마다 최적의 경로로 전송되는 방식으로, 송신부에서 보낸 패킷의 순서와 수신부에 도착하는 패킷의 순서가 다를 수 있다. 비연결 지향형
  >

<br />

정해진 시간 안이나 다량의 데이터를 연속으로 보낼 때는 가상 회선 방식이 적합

짧은 메시지의 일시적인 전송에는 데이터그램 방식 적합

네트워크 내의 한 노드가 다운되면 데이터그램 방식은 다른 경로를 새로 설정하지만, 가상회선 방식은 그 노드를 지나는 모든 가상회선을 잃게 된다.

<br />

## TCP 핸드셰이킹

연결을 시작할 때는 `3-way 핸드셰이킹`을, 연결을 종료할 때는 `4-way 핸드셰이킹`을 한다.

송신부와 수신부 간 연결을 제어 및 관리하도록 플래그(flag)값을 주고받는다.

- SYN: 동기화, 연결을 생성할 때 사용
- FIN: 종료, 연결을 끊을 때 사용
- ACK: 승인, 데이터를 전송하면 수신자가 받았음을 알려 줄 때 사용
- RST: 초기화, 연결을 재설정할 때 사용
- PSH: 밀다, 빠른 응답이 필요한 데이터를 응용 계층으로 즉시 전송할 때 사용
- URG: 긴급, 다른 데이터보다 우선순위가 높은 데이터를 전송할 때 사용

<br />

### 3-way 핸드셰이킹

상대방 컴퓨터와 세션을 수립하는 과정

<br />

1. 송신부와 수신부가 연결하기 위해 SYN 메시지를 보낸다. 이때, 임의의 숫자 N을 함께 보낸다. 송신부는 수신부로부터 응답이 오기 전까지 `SYN_SENT` 상태가 된다.
2. 수신부는 메시지를 받으면 ACK 메시지를 전송한다. ACK 메시지에는 송신부로부터 받은 N에 1을 더한 N+1 값을 함께 보낸다. 수신부에서도 송신부와의 연결을 확인하기 위해 SYN 메시지에 임의의 숫자인 M을 함께 보내며 `SYN_RECEIVE` 상태가 된다.
3. 송신부가 수신부로부터 ACK + SYN 메시지를 받으면 `ESTABLISHED` 상태가 된다.

   메시지에 대한 응답으로 ACK 메시지와 수신부로부터 받은 M에 1을 더한 M+1 값을 함께 보낸다.
   수신부가 메시지를 받으면 `ESTABLISHED` 상태가 된다.

<br />

### 4-way 핸드셰이킹

TCP 연결을 해제할 때 이뤄지는 과정

<br />

1. 송신부가 수산부와의 연결을 종료하려고 FIN 메시지를 보낸다. 이때, 송신부는 `FIN_WAIT1` 상태가 된다.
2. 수신부가 FIN 메시지를 받으면 `ACK` 메시지를 보낸다. 이때 수신부는 `CLOSE_WAIT` 상태가 된다. 송신부는 수신부에서 보낸 `ACK` 메시지를 받고 `FIN_WAIT2` 상태가 된다.
3. 수신부에서 연결을 종료할 준비가 끝나면 송신부에 FIN 메시지를 보내고 `LAST_WAIT` 상태가 된다.
4. 송신부는 서버로부터 받은 FIN 메시지에 응답하기 위해 ACK 메시지를 보내고 `TIME_WAIT` 상태가 되며 일정 시간이 지나면 `CLOSED` 상태가 된다.
   수신부는 송신부로부터 ACK 메시지를 받고 `CLOSED` 상태가 된다.

> TIME_WAIT 상태를 유지하는 이유
> FIN 메시지 전에 보낸 패킷이 FIN 메시지 수신보다 지연되어 발생하는 패킷 유실에 대비하기 위한다.
> 또한, 수신부에 ACK 메시지가 제대로 전달되지 않아 연결 해제가 이뤄지지 않은 경우도 대비한다.

<br />

## TCP 제어 방법

TCP 데이터 신뢰성을 보장하기 위한 제어 방법으로, 흐름 제어, 혼잡 제어, 오류 제어가 있다.

<br />

### 흐름 제어

흐름 제어는 데이터 송신부와 수신부에서 데이터 처리 속도의 차이 때문에 생기는 데이터 손실을 방지하는 방법이다.

- 정지-대기(stop-wait)
  송신부에서 데이터를 보낸 후 수신부로부터 ACK 메시지를 받을 때까지 다음 데이터를 보내지 않고 기다리는 방식이다.
  송신부에서 패킷을 보내고 일정 시간 동안 수신부로부터 ACK 메시지를 받지 못하면 패킷을 재전송한다.
  간단하지만, 이전 메시지에 대한 응답을 받아야만 다음 메시지를 보낼 수 있어서 시간 면에서 비효율적이다.
- 슬라이딩 윈도우(sliding window)
  송신부에서 데이터의 수신 여부를 확인하지 않고 수신부에서 설정한 윈도우 크기만큼 데이터를 연속적으로 보낼 수 있게 해서 데이터 흐름을 동적으로 제어하는 방식이다.
  3-way 핸드셰이킹 과정에서 응답받지 않고 보낼 수 있는 데이터의 최대 개수인 윈도우 크기가 정해진다.
    <br />
    
    1. 윈도우 크기가 4일 때 송신부에서 데이터 1과 2를 보내고 3과 4는 보낼 수 있지만, 아직 보내지 않은 상태다.
    2. 수신부에서 데이터 1과 2를 받았다는 ACK 메시지를 보낸다.
    3. 송신부는 수신부가 데이터 1과 2를 받은 것을 확인하고 윈도우를 2칸 이동한다. 따라서 3부터 6까지 데이터를 보낼 수 있는 상태가 된다. 송신부에서 데이터 3, 4, 5를 보낸다.
    4. 수신부에서 데이터 3과 4를 받았다는 ACK 메시지를 보낸다. 송신부는 수신부에서 데이터 3과 4를 받았다는 ACK 메시지는 받았지만, 데이터 5를 받았다는 ACK 메시지는 받지 못해서 윈도우를 2칸만 이동한다. 이제 데이터 7, 8도 보낼 수 있는 상태가 된다.
    
    이처럼 슬라이딩 윈도우 방식은 수신 여부와 상관없이 일정 크기의 데이터를 연속적으로 보내서 ACK 메시지를 받아야만 다음 메시지를 보낼 수 있는 정지-대기 방식의 단점을 보완한다.

- 혼잡 제어
  송신부의 데이터 전달 속도와 네트워크 속도 차이로 데이터 손실이 방생하는 것을 방지하기 위한 방법
  혼잡이 발생해 네트워크에 패킷이 쌓이면서 일정 시간 응답을 받지 못하면, 송신부에서는 메시지 전송에 실패했다고 판단해 수신부에 패킷을 재전송한다.
  이는 혼잡을 가중해 악순환을 야기하며, TCP는 혼잡 윈도우의 크기를 조절해 혼잡에 대응한다.
  - AIMD(additive increase multiplicative decrease)
    데이터를 전달할 때 합 증가 방식으로 혼잡 윈도우의 크기를 더해가면서 키운다. (RTT마다 1MSS씩 증가시킨다.)
    그리고 데이터 손실이 발생하면 혼잡 윈도우의 크기를 곱 감소 방식을 적용해 1/2배와 같이 배수 단위로 줄인다.
      <br />
      
      AIMD 방식은 시간이 지나면 여러 송신부 간에 네트워크 대역폭을 공평하게 사용할 수 있게 된다. 하지만 데이터 유실이 발생하면 윈도우 크기 증가폭 대비 윈도우 크기 감소폭이 크기 때문에 네트워크의 대역폭을 넓게 사용하기까지 시간이 오래 걸린다는 단점이 있다.

  - 느린 시작(slow start)
    윈도우 크기가 1인 상태에서 시작해 ACK 메시지를 수신할 때마다 윈도우 크기를 1씩 늘려나간다. 그러다 혼잡이 발생하면 윈도우 크기를 1로 확 줄이는 방식이다.
    보낼 수 있는 패킷 수가 지수 함수 형태로 증가한다.
      <br />
      
      이처럼 전송 가능한 패킷 수(윈도우 크기)를 지수 함수 형태로 늘리는 점은 AIMD 방식에서 초기에 전송 가능한 패킷 수가 적다는 단점을 보완한다.

  - 혼잡 회피(congestion avoidance)
      <br />
      
      윈도우 크기가 지수 함수 형태 증가하다가 혼잡이 발생하는 것을 방지하기 위해 윈도우 크기에 대한 임계점(threshold)을 정하는 방식이다.
      
      윈도우 크기가 임계점에 도달하면 윈도우 크기를 선형적으로 증가하게 된다.
      
      ACK 메시지를 받지 못해 타임아웃이 발생하면 타임아웃이 발생한 시점에서 윈도우 크기의 절반을 임계점으로 설정하고, 윈도우 크기를 초깃값으로 변경한다.

  - 빠른 회복(fast recovery)
    혼잡이 발생하면 혼잡 윈도우 크기를 절반으로 줄인 후 선형적으로 증가하는 방식이다.
    즉, 혼잡이 처음 발생하면 AIMD 방식으로 동작한다.
  - 빠른 재전송(fast retransmit)
    Duplicate ACK가 3번 발생하면 해당 시점의 윈도우 크기를 1/2로 줄인다.
    그 뒤로 ACK 메시지를 받으면 다시 윈도우 크기를 키우는 방식이다.
    Duplicate ACK은 패킷이 순서대로 도착하지 않아서 받아야 할 차례의 패킷을 ACK 메시지와 함께 요청하는 것을 뜻한다.
      <br />
      
      예를 들어, 송신부에서 패킷 0부터 5까지 보냈지만, 수신부에는 패킷 2가 오지 않았다. 수신부에서는 패킷 3, 4, 5에 대해 패킷 2를 보내라고 응답한다.
      
      해당 응답이 3번 반복되면 송신측에서는 패킷 2를 재전송한다. 이때 윈도우 크기는 1/2로 줄어든다.


혼잡 제어 정책 중 TCP Tahoe, TCP Reno

두 방식 모두 느린 시작 방식을 시작하다 임계점을 넘어가면 AIMD 방식으로 전환한다. 이때 임계점은 느린 시작 방식의 임계점을 의미해서 `ssthresh`라고 한다.

> TCP Tahoe
> 혼잡 위도우 크기를 지수적으로 키우다가 ssthresh 값인 4에 도달했을 때, AIMD를 사용해 혼잡 윈도우 크기를 선형적으로 키운다. 그러다가 혼잡 윈도우 크기가 6이 되었을 때 혼잡으로 3 Duplicate ACK가 발생한다. 그러면 혼잡 윈도우 크기를 1로 초기화하고(시작 지점) ssthresh 값을 혼잡이 발생한 크기인 6의 절반인 3으로 줄인다.이후 다시 윈도우 크기가 4일 때 타임아웃이 발생하면 윈도우 크기를 1로 초기화하고 ssthresh 값을 2로 변경한다.

> TCP Reno
> 혼잡 윈도우 크기를 지수적으로 키우다가 ssthresh 값인 4에 도달했을 때, AIMD를 사용해 혼잡 윈도우 크기를 선형적으로 키운다. 그러다가 혼잡 윈도우 크기가 6에 도달했을 때 3 Duplicate ACK가 발생하면 혼잡 윈도우의 크기를 절반으로 줄이고(시작 지점) ssthresh 값도 혼잡 윈도우 크기와 동일하게 설정한다. 하지만 혼잡 윈도우 크기가 5가 되었을 때 타임아웃이 발생하면 ssthresh 값은 유지하지만, 혼잡 윈도우 크기는 1로 줄인다. 이후 혼잡 윈도우 크기는 지수적으로 증가하다가 ssthresh 값인 3에 도달하면 선형적으로 증가한다.

<br />

## 오류제어

`오류제어`(error control)는 통신 중 데이터에 오류 또는 유실이 발생할 때 데이터의 신뢰성을 보장하기 위해 오류를 제어하는 방식이다.

데이터의 오류 또는 유실 발생 인지 경우

- 수신부에서 잘못된 데이터를 받았다는 응답인 NAK(Negative Acknowledge) 메시지를 보낸 경우
- 3 Duplicate ACK가 발생할 때
- 수신부로부터 ACK 메시지를 받지 못해 타임아웃이 발생할 때

오류 제어 방법

<br />

### 정지-대기

송신한 패킷에 대한 ACK 메시지를 일정 시간 동안 받지 못해 타임아웃이 발생하면 해당 패킷을 다시 보내는 방식이다.

이 방식은 송신부에서 데이터를 1개만 보내고 메시지를 기다려야 하기 때문에 `ARQ` 방식이 사용된다.

> ARQ(Automatic Repeat Request) : 재전송 요청

<br />

### Go-Back-N ARQ

송신부에서 연속적으로 데이터를 보냈을 때 누락된 데이터가 있으면 송신부에서 해당 데이터부터 재전송하는 방식이다.

송신부에서 패킷 0부터 패킷 2까지 보냈을 때 수신부에서 ACK 3 메시지를 보내면 송신부는 다음에 패킷 3부터 보낸다. 그리고 패킷 3부터 패킷 5까지 보냈을 때 ACK 4 메시지를 받으면 패킷 4와 패킷 5를 재전송한다.

<br />

### Selective-Repeat ARQ

송신부에서 연속적으로 데이터를 보냈을 때 누락된 데이터가 있으면 수신부에서 해당 데이터만 재전송을 요청하는 방식이다.

특정 패킷만을 재전송한다는 점은 효율적으로 보이지만, 받은 패킷을 재정렬하는 로직이 추가로 필요하다.

<br />

## UDP

UDP(User Datagram Protocol)은 TCP와 마찬가지로 전송계층에 해당하는 네트워크 프로토콜이다.

UDP는 송신부와 수신부 간 연결을 지원하지 않고 데이터그램 형태의 통신을 지원한다.

그래서 TCP와 달리 3-way 핸드셰이킹 같은 과정 없이 패킷을 바로 송수신하게 된다.

이 방식은 신뢰성이 낮지만 속도가 빠르다는 장점이 있다.

<br />

### UDP 특징

- 송신부와 수신부의 연결이 보장되지 않는 비연결형 서비스이다.
- 패킷이 서로 다른 회선으로 교환될 수 있는 데이터그램 패킷 교환 방식이다.
- 송신부에서 전달한 패킷 순서와 수신부에서 받은 패킷 순서가 다를 수 있다.
- 패킷의 수신 여부를 확인하지 않는다.
- 1:1 통신, 1:N 통신, N:N 통신 모두 가능하다.
- 데이터의 신뢰성이 낮다.
- 데이터의 전송 속도가 빠르다.

|                | TCP            | UDP                 |
| -------------- | -------------- | ------------------- |
| 연결 방식      | 연결형 서비스  | 비연결형 서비스     |
| 패킷 교환 방식 | 가상 회선 방식 | 데이터그램 방식     |
| 전송 순서      | 순서 보장      | 순서가 바뀔 수 있음 |
| 수신 여부      | 확인           | 확인하지 않음       |
| 통신 방식      | 1:1 통신       | 1:1, 1:N, N:N 통신  |
| 신뢰성         | 높음           | 낮음                |
| 속도           | 느림           | 빠름                |

<br />

### UDP의 오류 검출

UDP는 최소한의 신뢰성을 보장하기 위해 체크섬(checksum) 방식으로 오류를 검출할 수 있다.

체크섬은 데이터의 무결성을 보장하는 간단한 방법이다.

<br />

체크섬을 만들기 위한 데이터를 모두 더한다.

이때 오버플로우되는 캐리가 발생하면 해당 캐리를 떼서 데이터에 다시 더한 후 1의 보수를 취해 체크섬을 만든다.

UDP 송신부는 UDP의 헤더, IP 헤더의 일부 정보(발신 IP 주소, 수신 IP 주소, 프로토콜 ID 등)와 데이터로 체크섬을 값을 생성한다.

생성한 체크섬 값을 UDP 헤더의 체크섬 영역에 넣어서 수신부에 보낸다.

수신부는 체크섬을 포함한 모든 값을 더해 비트가 모두 1이 나오는지 확인한다.(AND 연산)

하지만 체크섬을 이용해도 오류를 100% 검출할 수 있는 것은 아니다.

데이터의 순서가 바뀌거나 오류가 발생해도 체크섬이 같은 경우가 있기 때문이며, UDP의 체크섬은 선택 사항이므로 송신부에서 체크섬 값을 0으로 보내면 수신부는 체크섬을 계산하지 않는다.
