## 서버의 event를 client로 보내는 4가지 방법

### Polling

일정 시간마다 서버에 요청을 보내 데이터가 갱신되었는지 확인하여 갱신된 값이 있다면 데이터를 응답받는 방식이다. 클라이언트, 서버 모두 구현이 간단하다.

실시간성이 중요하지 않다면 사용할 수 있는 방법이다.

- 클라이언트가 http request를 서버로 계속 보내서 이벤트 내용을 전달받는 방식
- 클라이언트가 계속적으로 request를 보내기 때문에 클라이언트가 많아지면 서버의 부담이 급증한다.
- http request connection을 맺고 끊는 것 자체가 부담스러운 방식
- 실시간 정도의 빠른 응답을 기대하기 어려움
- http 오버헤드가 발생
- 일정하게 갱신되는 서버 데이터의 경우 유용하게 사용

<aside>
📙 HTTP OverHead
정보의 신뢰성을 판단하기 위해 보내지는 헤더 정보(전송 데이터와 관련없는 정보)로 데이터량, 처리시간이 증가한다.

</aside>

<br />

### Long-Polling

요청을 보낸 후 서버에서 변경이 일어날 때까지 기다리는 방법

실시간 메시지 전달이 중요하지만 서버의 상태가 빈번하게 변경되지 않는 경우에 적합한 방식이다.

- 서버에서 접속 시간을 길게하는 방식
  - 클라이언트에서 서버로 http request 전송
  - 서버 응답 데이터가 없으면 기다림, 이벤트가 존재하면 그 순간 response 메시지를 전달 후 연결 해제
  - 클라이언트에서 다시 http request를 전송하여 서버의 다음 이벤트 대기
- polling 방식보다 서버 부담이 줄지만, 이벤트 시간 간격이 좁다면 차이가 없다.
- 다수의 클라이언트에게 이벤트가 동시에 발생하면 서버 부담 급증

<br />

### SSE(Server-Sent-Event)

클라이언트와 서버가 한 번 연결을 맺고 난 후 일정시간 동안 서버에서 변경이 발생할 때마다 데이터를 전송받는 방법이다.

Long Polling 방식에 비해 Server sent event는 다시 요청을 안해도 된다는 장점을 가지고 있다.

서버에서 클라이언트로 text message를 보내는 브라우저 기반 웹 애플리케이션의 기술이며 HTTP의 persistent connections을 기반으로 하는 HTML5 표준 기술이다.

- 서버의 데이터를 실시간, 지속적으로 Streaming하는 기술
- html5 표준, 웹소켓의 역할
- 양방향이 아닌 server → client의 단방향
- 재접속의 저수준 처리 자동 지원

<br />

### Websocket

클라이언트와 서버가 HTTP 기반으로 HandShaking을 한 후 ws 프로토콜을 통해 상호간 응답을 하는 방식이다.

WebSocket은 채팅방과 같이 양방향 통신이 가능하다.

앞의 http 요청 응답 방식들은 요청한 클라이언트에게만 응답이 가능했다.

WebSocket방식의 경우 ws 프로토콜을 통해 웹소켓 포트에 접속해 있는 모든 클라이언트에게 이벤트 방식으로 응답할 수 있다.

- 양방향 채널을 이용한 양방향 통신
- ws 프로토콜을 통해 웹소켓 포트에 연결되어 있는 모든 클라이언트에게 이벤트 방식으로 응답
- 최초 접속이 http request를 통한 handshaking 과정을 통해 이루어짐
- websocket 프로토콜을 위한 전이중 연결과 웹소켓 서버 필요
