## 선형 자료구조

연속적으로 데이터가 나열되는 자료구조

- 배열
- 리스트
- 스택
- 큐

<br />

### 배열

정해진 크기만큼 데이터가 일렬로 저장되는 정적 자료구조

각 데이터를 배열의 요소(`element`)라고 하며 데이터를 가리키는 번호를 `인덱스`라고 한다.

- 특정 인덱스의 데이터에 접근하는 데 걸리는 시간 복잡도 `O(1)`
  배열의 첫 번째 데이터에 대한 주소 값에 (데이터 타입의 메모리 크기) x (접근하려는 데이터의 인덱스)를 더한다.
- 데이터를 검색하는 데 걸리는 시간 복잡도 `O(n)`
- 특정 위치에 새로운 데이터를 삽입하는 데 걸리는 시간 복잡도 `O(n)`
  추가하려는 위치에 있던 기존 데이터를 뒤로 한 칸 미뤄야 하기 때문이다.
  만약, 데이터를 추가하려는 위치가 배열의 맨 마지막인데 해당 위치에 데이터를 저장할 수 있는 공간이 있는 경우 `O(1)` 시간 복잡도를 가진다. [기존 배열의 마지막 인덱스 + 1]
- 특정 인덱스의 데이터를 삭제하는 데 걸리는 시간 복잡도 `O(n)`
  단, 삭제하려는 데이터가 마지막 데이터라면 시간 복잡도 `O(1)`

<br />

### 연결 리스트 (단순 연결 리스트)

배열과 달리 크기가 정해져 있지 않은 동적 자료구조

연결 리스트는 여러 개의 노드로 구성되어 있다.

노드는 데이터와 다음 노드가 저장된 주소 값을 가지고 있다.

- 헤드 (head)
- 테일 (tail)

연결리스트에서는 새로운 노드가 추가되어도 기존 노드들의 위치를 변경하지 않아도 되므로 시간 면에서 효율적이다.

하지만 배열과 달리 인덱스가 없어서 특정 위치의 데이터에 접근하는 데 배열보다 시간이 오래 걸린다.

- 특정 데이터를 검색하는 데 드는 시간 복잡도 `O(n)`
  첫 번째 노드부터 하나씩 값을 확인하는 선형 탐색을 해야 한다.
- 데이터를 추가하는 연산 자체는 `O(1)`
  데이터를 추가하려는 위치로 이동하기까지 `O(n)`이 소요된다.
  → 연결 리스트의 맨 앞에 데이터를 추가하는 경우에는 `O(1)`이 소요되고, 나머지 위치에 노드를 추가하는 경우에는 `O(n)`이 소요된다.
- 첫 번째 데이터를 삭제하는 경우 `O(1)`
  해당 위치까지 이동하기 위한 연산은 최대 `O(n)`

<br />

### 이중 연결 리스트 (double linked linear list)

노드의 앞 노드의 주소 값과 다음 노드의 주소 값을 모두 저장한다.

그래서 단순 연결 리스트와 달리 양방향 탐색이 가능한 구조다.

- 단순 연결 리스트보다 구현하기 어렵고, 한 노드당 주소 값 2개를 저장해야 해서 메모리를 많이 차지한다는 단점이 있다.
- 하지만 노드의 연결 순서와 무관하게 노드를 연속적으로 탐색해야 하는 경우에 단순 연결 리스트 대비 시간 면에서 효율적이다.

<br />

### 원형 연결 리스트 (circular linked linear list)

마지막 노드가 `NULL` 값이 아니라 첫 번째 노드의 주소 값을 가리키는 구조다.

다른 연결 리스트와 달리 헤드가 마지막 노드를 가리키면 삽입과 삭제 연산을 효율적으로 수행할 수 있다.

- 새로운 노드를 맨 마지막, 또는 맨 앞에 삽입할 때 상수 시간이 소요된다는 장점이 있다.
- 헤드가 마지막 노드를 가리키고 있어서 `O(1)`에 마지막 노드에 접근할 수 있다.

<br />

### 스택

데이터를 쌓는 형태로, `LIFO`(last in first out, 후입선출)

| push    | 스택에 새로운 데이터 삽입           | O(1) |
| ------- | ----------------------------------- | ---- |
| pop     | 스택에서 가장 위에 있는 데이터 삭제 | O(1) |
| peek    | 스택에서 가장 위에 있는 데이터 확인 | O(1) |
| isEmpty | 스택이 비어 있는지 확인             | O(1) |
| isFull  | 스택이 가득 찼는지 확인             | O(1) |

<br />

### 큐

데이터가 순차적으로 들어오는 형태, `FIFO`(first in first out, 선입선출)

- 큐의 맨 앞 `front`
- 큐의 맨 뒤 `rear`

| enqueue | 큐의 rear에 새로운 데이터 삽입 | O(1) |
| ------- | ------------------------------ | ---- |
| dequeue | 큐의 front에서 데이터 삭제     | O(1) |
| peek    | 큐의 front에 있는 데이터 확인  | O(1) |
| isEmpty | 큐가 비어 있는지 확인          | O(1) |
| isFull  | 큐가 가득 찼는지 확인          | O(1) |

> 순환 큐, 원형 큐(circular queue)
> 삽입 연산을 할 때 배열의 앞부분에 데이터를 삽입한다.
> 순환 큐를 구현하면 배열의 시작과 끝이 구분되지 않아 데이터의 삽입과 삭제를 유연하게 수행할 수 있다.

<br />

### 덱 (deque)

양쪽 끝에서 데이터의 삽입과 삭제가 모두 가능한 자료구조로, 큐와 스택을 합친 형태다

<br />

## 비선형 자료구조

하나의 데이터 뒤에 N개의 데이터가 이어질 수 있는, 1:N 또는 N:N 구조로 데이터가 나열되는 자료구조

선형 자료구조와 달리 데이터를 하나하나 탐색하지 않아도 원하는 데이터를 찾을 수 있다.

<br />

### 그래프

데이터를 포함하는 정점(v, 노드)과 간선(e)으로 구성된 자료구조

- 인접: 두 정점이 간선으로 연결되어 있으면 인접하다고 한다.
- 차수: 정점에 연결된 간선의 수
- 진입 차수: 해당 정점으로 향하는 간선의 수
- 진출 차수: 해당 정점에서 나가는 간선의 수
- 경로: 한 정점에서 다른 정점으로 이어지는 정점들의 리스트
- 경로 길이: 경로를 구성하는 간선의 수
- 단순 경로: 모두 다른 정점으로 구성된 경로
- 사이클: 한 정점에서 시작해 같은 정점으로 돌아올 수 있는 경로

<br />

### 무방향 그래프

간선에 방향성이 없는 그래프 `(A, B)`

정점의 개수가 n일 때 최대 간선의 개수는 `n x (n - 1) / 2`이다.

<br />

### 방향 그래프

간선에 방향성이 있는 그래프 `<A, B>`

정점의 개수가 n일 때 최대 간선의 개수는 `n x (n  - 1)`

- 부분 그래프
  기존 그래프에서 일부 정점 또는 간선을 제외한 그래프
- 가중치 그래프
  간선에 비용이나 가중치가 할당된 그래프
- 완전 그래프
  간선을 최대로 가진 그래프로, 연결 그래프라고도 한다. 정점의 개수가 n일 때 무방향 그래프의 간선 수가 n x (n - 1) / 2이면 완전 그래프라고도 한다. 이와 마찬가지로 방향그래프의 간선의 수가 n x (n - 1)이면 완전 그래프다.
- 유향 비순환 그래프 (DAG)
  방향 그래프이면서 사이클이 없는 그래프

<br />

### 경로 탐색

- 너비 우선 탐색 (BFS)
  탐색을 시작하는 정점에서 가까운 정점을 먼저 탐색하는 방식, 큐로 구현 가능
- 깊이 우선 탐색 (DFS)
  시작 정점에서 탐색 가능한 최대 깊이의 정점까지 탐색하는 방식, 스택과 재귀함수로 구현 가능

<br />

### 트리

그래프의 한 종류로 사이클이 없어서 계층적 관계를 표현할 수 있다.

- 루트 노드: 부모 노드가 없는 노드로, 트리에는 하나의 루트 노드가 존재한다.
- 부모 노드: 루트 노드 방향으로 연결된 노드
- 자식 노드: 루트 노드의 반대 방향으로 연결된 노드
- 단말 노드: 자식 노드가 없는 노드
- 형제 노드: 부모 노드가 같은 노드
- 레벨: 루트 노드로부터 노드의 상태적 위치를 의미한다. 일반적으로 루트 노드의 레벨은 0
- 높이: 트리의 최대 레벨 + 1
- 차수: 자식 노드의 개수

<br />

### 이진 트리

자식 노드가 최대 2개인 트리

- 완전 이진 트리
  트리의 마지막 레벨을 제외한 모든 레벨에 노드가 채워져 있으며, 마지막 레벨은 왼쪽에서부터 오른쪽으로 노드가 채워져 있는 이진 트리
- 포화 이진 트리
  트리의 마지막 레벨까지 노드가 모두 채워져 있는 이진 트리이며, 포화 이진 트리는 완전 이진 트리라고 할 수 있다.
- 이진 탐색 트리(BST)
  한 노드의 왼쪽 서브 트리는 해당 노드의 값보다 작은 값을 가진 노드로 구성되고, 오른쪽 서브 트리는 해당 노드의 값보다 큰 값을 가진 노드로 구성된 트리

`균형 잡힌 이진 탐색 트리`에서는 루트 노드와 가까운 노드일 수록 검색해야 하는 노드 개수가 절반으로 줄어든다.

따라서 값을 검색하는 데 `O(logn)`이 소요된다. 하지만 균형이 잡히지 않은 이진 탐색 트리에서는 검색하는 데 시간 복잡도 `O(n)`이 소요되므로 이진 탐색 트리를 이용하는 장점이 사라진다.

<br />

### 균형 이진 탐색 트리

삽입이나 삭제 연산을 수행해도 트리의 균형을 유지하는 트리

- 레드-블랙 트리
  노드가 검은색 또는 빨간색인 트리로, 정해진 규칙을 만족하면서 균형을 유지하는 트리

- AVL 트리
  자가 균형 이진 탐색 트리로, 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이를 유지해 균형을 잡는 트리이다.
  높이 차이를 알려면 왼쪽 서브 트리의 높이에서 오른쪽 서브 트리의 높이를 뺀 값인 BF를 사용한다. > LL 불균형
  왼쪽으로 불균형을 이룰 경우에 가운데 노드를 중심으로 오른쪽 회전해서 균형을 맞춘다.

      RR 불균형
      오른쪽으로 불균형을 이룰 경우에 가운데 노드를 중심으로 왼쪽으로 회전해서 균형을 맞춘다.

      LR 불균형
      왼쪽, 오른쪽으로 불균형을 이룰 경우에 마지막 레벨에 위치한 노드를 중심으로 왼쪽으로 회전한 후 다시 오른쪽으로 회전해서 균형을 맞춘다.

      RL 불균형
      오른쪽, 왼쪽으로 불균형을 이룰 경우에 마지막 레벨에 위치한 노드를 중심으로 오른쪽으로 회전한 후 다시 왼쪽으로 회전해서 균형을 맞춘다.

<br />

### 우선순위 큐

우선순위가 높은 데이터가 먼저 나오는 자료구조

일반적으로 가장 효율적인 힙을 사용해 구현한다.

<br />

### 힙

완전 이진 트리로, 최댓값 또는 최솟값을 빠르게 찾을 수 있는 자료구조다.

- 최대 힙: 부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진 트리
- 최소 힙: 부모 노드의 값이 자식 노드의 값보다 작거나 같은 완전 이진 트리

1.  삽입 연산

    힙에 데이터를 삽입할 때는 힙의 맨 끝에서 이루어진다.
    부모 노드와 우선순위(최댓값 또는 최솟값)을 비교해 부모 노드보다 우선순위가 높으면 위치를 바꾸면서 루트 노드까지 비교한다.

2.  삭제 연산
    힙에서 데이터 삭제는 우선순위가 가장 높은 노드를 삭제하는 연산이다.
    즉, 루트 노드를 삭제하게 된다.
    삭제한 후에는 루트 노드 자리에 힙의 마지막 노드(마지막 레벨의 가장 오른쪽 노드)를 옮긴 후 힙을 재정렬한다.

<br />

### 해시 테이블

하나의 키에 대해 하나의 값을 저장하는 형태의 자료구조

키는 해시 함수를 사용해 해시를 얻을 수 있다.

해시는 값이 저장되어 있는 해시 테이블의 인덱스를 찾을 수 있는 값이다.

따라서 연산은 평균적으로 `O(1)`의 시간 복잡도를 갖는다.

<br />

하지만 해시 테이블에는 `해시 충돌`이라는 단점이 있다.
해시 충돌은 서로 다른 키에 대해 같은 해시가 도출되는 것을 말한다.
해시 충돌 문제를 해결하기 위한 방법에는 `체이닝`과 `개방 주소법`이 있다.

- `체이닝(chaining)`
  해시 충돌이 발생하면 같은 해시가 나오는 키의 값을 연결 리스트에 저장하는 방식이다.
  연결 리스트에 노드를 저장하므로 저장 공간에 대한 제약이 적다는 장점이 있다.
  하지만 하나의 해시(인덱스)에 노드가 몰릴 수 있다는 단점이 있다.
- `개방 주소법(open addressing)`
  해시 충돌이 발생했을 때 해당 해시가 아닌 비어 있는 공간에 값을 저장하는 방식이다.
  개방 주소법에는 `선형 조사법`, `이차 조사법`, `이중 해싱`이 있다. > 선형 조사법
  h[n]에서 해시 충돌이 발생하면 h[n+1], h[n+2]와 같이 다음 인덱스로 이동하면서 빈 공간을 찾는 방식이다. 선형 조사법은 충돌이 발생하면 다음 인덱스에 데이터를 저장하므로 특정 인덱스 범위에 데이터가 몰리는 `군집화 현상`이 나타나는 단점이 있다. >

      > 이차 조사법
      h[n]에서 해시 충돌이 발생하면 h[n+1x1], h[n+2x2], h[n+3x3]과 같이 거듭제곱한 인덱스만큼 이동하고 빈 공간을 찾으면 데이터를 저장하는 방식이다. 이차 조사법은 선형 조사법보다 군집화 현상이 적지만, 완전히 해결한다고 할 수는 없다.
      >

      > 이중 해싱
      해시 충돌이 발생하면 다른 해시 함수를 한 번 더 적용하는 방법이다.
      >
